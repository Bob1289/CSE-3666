\documentclass{article}
\usepackage[utf8]{inputenc}

\title{Lab 9}
\author{Benny Chen}
\date{\today}

\usepackage{color}
\usepackage{amsthm}
\usepackage{amssymb} 
\usepackage{amsmath}
\usepackage{listings}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage[table,xcdraw]{xcolor}
\usepackage[hidelinks]{hyperref}

\lstdefinelanguage[mips]{Assembler}{%
  % so listings can detect directives and register names
  alsoletter={.\$},
  % strings, characters, and comments
  morestring=[b]",
  morestring=[b]',
  morecomment=[l]\#,
  % instructions
  morekeywords={[1]abs,abs.d,abs.s,add,add.d,add.s,addi,addiu,addu,%
    and,andi,b,bc1f,bc1t,beq,beqz,bge,bgeu,bgez,bgezal,bgt,bgtu,%
    bgtz,ble,bleu,blez,blt,bltu,bltz,bltzal,bne,bnez,break,c.eq.d,%
    c.eq.s,c.le.d,c.le.s,c.lt.d,c.lt.s,ceil.w.d,ceil.w.s,clo,clz,%
    cvt.d.s,cvt.d.w,cvt.s.d,cvt.s.w,cvt.w.d,cvt.w.s,div,div.d,div.s,%
    divu,ecall,eret,floor.w.d,floor.w.s,j,jal,jalr,jr,l.d,l.s,la,lb,lbu,%
    ld,ldc1,lh,lhu,li,ll,lui,lw,lwc1,lwl,lwr,madd,maddu,mfc0,mfc1,%
    mfc1.d,mfhi,mflo,mov.d,mov.s,move,movf,movf.d,movf.s,movn,movn.d,%
    movn.s,movt,movt.d,movt.s,movz,movz.d,movz.s,msub,msubu,mtc0,mtc1,%
    mtc1.d,mthi,mtlo,mul,mul.d,mul.s,mulo,mulou,mult,multu,mulu,mv,neg,%
    neg.d,neg.s,negu,nop,nor,not,or,ori,rem,remu,rol,ror,round.w.d,%
    round.w.s,s.d,s.s,sb,sc,sd,sdc1,seq,sge,sgeu,sgt,sgtu,sh,sle,%
    sleu,sll,sllv,slt,slti,sltiu,sltu,sne,sqrt.d,sqrt.s,sra,srav,srl,%
    srlv,sub,sub.d,sub.s,subi,subiu,subu,sw,swc1,swl,swr,syscall,teq,%
    teqi,tge,tgei,tgeiu,tgeu,tlt,tlti,tltiu,tltu,tne,tnei,trunc.w.d,%
    trunc.w.s,ulh,ulhu,ulw,ush,usw,xor,xori},
  % assembler directives
  morekeywords={[2].align,.ascii,.asciiz,.byte,.data,.double,.extern,%
    .float,.globl,.half,.kdata,.ktext,.set,.space,.text,.word},
  % register names
  morekeywords={[3]\$0,\$1,\$2,\$3,\$4,\$5,\$6,\$7,\$8,\$9,\$10,\$11,%
    \$12,\$13,\$14,\$15,\$16,\$17,\$18,\$19,\$20,\$21,\$22,\$23,\$24,%
    \$25,\$26,\$27,\$28,\$29,\$30,\$31,%
    \$zero,\$at,\$v0,\$v1,\$a0,\$a1,\$a2,\$a3,\$t0,\$t1,\$t2,\$t3,\$t4,
    \$t5,\$t6,\$t7,\$s0,\$s1,\$s2,\$s3,\$s4,\$s5,\$s6,\$s7,\$t8,\$t9,%
    \$k0,\$k1,\$gp,\$sp,\$fp,\$ra},
}[strings,comments,keywords]

\definecolor{CommentGreen}{rgb}{0,.6,0}
\lstset{
  language=[mips]Assembler,
  escapechar=@, % include LaTeX code between `@' characters
  keepspaces,   % needed to preserve spacing with lstinline
  basicstyle=\small\ttfamily\bfseries,
  commentstyle=\color{CommentGreen},
  stringstyle=\color{cyan},
  showstringspaces=false,
  keywordstyle=[1]\color{blue},    % instructions
  keywordstyle=[2]\color{magenta}, % directives
  keywordstyle=[3]\color{red},     % registers
}

\lstdefinestyle{Python}{
    language        = Python,
    frame           = lines, 
    basicstyle      = \footnotesize,
    keywordstyle    = \color{blue},
    stringstyle     = \color{green},
    commentstyle    = \color{red}\ttfamily
}

\begin{document}

\maketitle

\section*{Task 1}

\begin{table}[h]
    \resizebox{\textwidth}{!}{%
    \begin{tabular}{|l|c|c|c|c|}
    \hline
    \multicolumn{1}{|c|}{Address} & Cache index & Tag                       & Block offset & Hit/Miss \\ \hline
    0x10010000                    & 0     & 0x00200200                      & 0            & Miss     \\ \hline
    0x10010004                    & 0     & 0x00200200                      & 4            & Hit      \\ \hline
    0x10010008                    & 0     & \multicolumn{1}{l|}{0x00200200} & 8            & Hit      \\ \hline
    0x1001000C                    & 0     & 0x00200200                      & 12           & Hit      \\ \hline
    0x10010010                    & 1     & \multicolumn{1}{l|}{0x00200200} & 0            & Miss     \\ \hline
    0x10010014                    & 1     & \multicolumn{1}{l|}{0x00200200} & 4            & Hit      \\ \hline
    \end{tabular}%
    }
\end{table}

\noindent
The Cache index has 3 bits, the block offset again has 4 bits, and the tag has 25 bits
as the complete address is 32 bits, meaning 32 bits - 3 bits - 4 bits = 25 bits. 
For the first 2 accesses, the tag and cache index are the same, only the block offset changes.
The first operation is a miss as it puts the element in place with the next three will hit.
This makes it a 75\% hit rate which I predicted. There are hits 3 in a row, then a miss which repeats.

\section*{Task 2}

\begin{table}[h]
    \resizebox{\textwidth}{!}{%
    \begin{tabular}{|c|c|c|c|}
    \hline
    Number of blocks & Cache size & Hit rate & Miss count \\ \hline
    8                & 128 bytes  & 75\%     & 3072       \\ \hline
    16               & 256 bytes  & 75\%     & 3072       \\ \hline
    32               & 512 bytes  & 75\%     & 3072       \\ \hline
    64               & 1024 bytes & 99\%     & 64         \\ \hline
    128              & 2048 bytes & 99\%     & 64         \\ \hline
    \end{tabular}%
    }
\end{table}

\noindent
My prediction for this task is the same as the previous task.
We can first see that when the array size is greater than the cache size, the hit rate is 75\%.
For cache sizes of 1024 bytes and 2048 bytes, the hit rate is 99\% as at that point,
the cache size is greater than the array size.
When the cache size is greater than the array size, the cache is populated with all the elements
and the hit rate is close to 100\%. If warray is doubled, we can still see
how it would behave with how it previously behaved. Again, if the cache size is greater than the array size
rather than if the array size is greater than the cache size, the hit rate would be greater. Therefore,
if we double the warray size, the hit rate for 64 blocks would have a hit rate of 75\% and 3072 misses.

\end{document}